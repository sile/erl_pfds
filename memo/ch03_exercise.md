Exercise 3.1
------------

仮定:
- 存在しないノードのrankは`0`と仮定する
  - あるノードが右の子ノードしか保持していない場合でも、左に(存在しない)子ノードのrankは`0`として扱う
  - そうしないと、全てのノードが右の子だけを保持する木が生成できてしまう

証明(ではないメモ書き):
- `n = 7`だとする
- もし全てのノードが右の子だけを保持するとしたら、最大のrankは`7`となるが、それは`leftist property`に反する
  - ex: ルートのノードの右の子のrankが`6`で、左の(仮想的な)子のrankが`0`になるため
- ルートノードの直接の子で`leftist property`を満たすためには、最低限、左右の子のrankを等しくする必要がある
  - 左右の子のrankをそれぞれ`3`にするとする (半分に分配する)
    - 孫以降の要素は、全ての右の子ノードとして保持するものとする
  - ルートノード直下の子に関しては`leftist property`を満たせた
  - ただし、直下のそれぞれの子ノードの子ノード(ルートの孫ノード)に関しては、また`leftist property`が崩れた
  - => 一段レベルを下げて、同じことを繰り返していく必要がある
  - => 一段レベルが下がるごとに、分配可能なノード数は半分に減っていくので、結果として最大のrankはルートからのもので、対数オーダーとなる

Exercise 3.3
------------

計算量の試算:

```
%% from_list/1の漸化式:
%%  - C=各のヒープの要素数
%%  - N=マージ対象のリストの数
f(0, C) = 0
f(1, C) = 1
f(N, C) = log(C) * N / 2 + f(N / 2, C * 2)  % `log(C) * N/2`はこのレベルでのリストのマージに要するコスト

f(N) = N + f(N, 1)  % 最初のNはシングルトンリストの生成コスト


%% 適用例:
f(0) = 0 + 0                                                       = 0
f(1) = 1 + 1                                                       = 2
f(2) = 2 + f(2, 1) = 2 + (1 * 1) + 1                               = 4
f(4) = 4 + f(4, 1) = 4 + (1 * 2) + (2 * 1) + 1                     = 9
f(8) = 8 + f(8, 1) = 8 + (1 * 4) + (2 * 2) + (3 * 1) + 1           = 20
f(16)=16 + f(16,1) = 16+ (1 * 8) + (2 * 4) + (3 * 2) + (4 * 1) + 1 = 43


%% 増分の漸化式:
d(N) = N + d1(N / 4)

d1(0) = 0
d1(N) = N + d1(N / 2)

%% => Nが二倍になると、オーダーは`N + 2^log(N/2) - 1`だけ増える
%% => `N + 2^log(N/2) - 1  ==  N + N/2 - 1  <  2N`

%% トータルのコストを転換すると:
%% (N + N/2 - 1) + (N/2 + N/2/2 - 1) + (N/2/2 + N/2/2/2 - 1) + ...
%% => N + N/2 * 2 + N/2/2 * 2 ... - log(N)
%% => N*2 + N/2 + N/4 + ... - log(N)

%% 計算式:
%% N + (2^log(N) - 1) - log(N)
%%
%% => O(N)
```
