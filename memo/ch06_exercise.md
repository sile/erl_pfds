Exercise 6.2
------------

実装的には、check関数の判定部分が`lenr =< lenf`から`lenr =< 2*lenf`に変わるだけ。

### (a)

不変項: `D(i) =< min(3i, 2|f| - |r|)`

#### 証明:

もともとのものとほぼ同様なので省略

回転につながらないtail時に、(二つではなく)先頭三つのデビットを支払うようにすれば不変項は維持される


### (b)

`|f| >= |r|`の場合:
- 回転のタイミング:
  - `1, 3, 7, 15, 31, 63, ... => f(i) = 2^i - 1 (i=1..)`
  - `snoc*100 => tail*100`の間に実行される回転の数は6回
- reverse関数の合計計算量は`100` (全要素がそれぞれ一回だけreverseの対象となる)
- append関数の合計計算量は:
   - `sum([f(i) | i [1..], f(i) =< 100]) = 120`

`2|f| >= |r|`の場合:
- 回転のタイミング:
  - `1, 4, 13, 40, ... => f(1)=1; f(i)=f(i-1)*3 + 1`
  - `snoc*100 => tail*100`の間に実行される回転の数は4回
- reverse関数の合計計算量は`100` (全要素がそれぞれ一回だけreverseの対象となる)
- append関数の合計計算量は:
   - `sum([f(i) | i [1..], f(i) =< 100]) = 58`

結論:
- append関数の計算量の差により、このケースでは、後者の方が効率が良い
- 全般的に、回転のタイミングを遅らせた方が、データ構造が共有されない場合の効率は(定数倍)良くなるが、償却計算量は(定数倍)悪くなる (tailのコストが増える)
